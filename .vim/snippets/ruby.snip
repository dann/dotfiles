snippet am
    alias_method :${1:new_name}, :${2:old_name}

snippet anr
    assert_nothing_raised(${1:Exception}) { ${2} }

snippet as
    assert ${1:test}, "${2:failure_message}"

snippet ase
    assert_equal ${1:expected}, ${2:actual}

snippet asid
    assert_in_delta ${1:expected_float}, ${2:actual_float}, ${3:delta_float}

snippet asio
    assert_instance_of ${1:ExpectedClass}, ${2:actual_instance}

snippet asko
    assert_kind_of ${1:ExpectedKind}, ${2:actual_instance}

snippet asm
    assert_match /${1:expected_pattern}/, ${2:actual_string}

snippet asn
    assert_nil ${1:instance}

snippet asne
    assert_not_equal ${1:unexpected}, ${2:actual}

snippet asnm
    assert_no_match /${1:unexpected_pattern}/, ${2:actual_string}

snippet asnn
    assert_not_nil ${1:instance}

snippet asns
    assert_not_same ${1:unexpected}, ${2:actual}

snippet asnt
    assert_nothing_thrown { ${1} }

snippet aso
    assert_operator ${1:left}, :${2:operator}, ${3:right}

snippet asr
    assert_raise(${1:Exception}) { ${2} }

snippet asrt
    assert_respond_to ${1:object}, :${2:method}

snippet ass
    assert_send [${1:object}, :${2:message}, ${3:args}]

snippet ast
    assert_throws(:${1:expected}) { ${2} }

snippet bm
    TESTS = ${1:10_000}
    Benchmark.bmbm do |results|
    	${2}
    end

snippet case
    case ${1}
    when ${2}
    else
    	${3}
    end

snippet class
    class ${1:`Snippet_RubyClassNameFromFilename()`}${2}
    	${3}
    end

snippet classe
    class ${1:ErrorClassName} < ${2:StandardError}; end${3}

snippet def
    def ${1:name}
    	${2}
    end

snippet defi
    def initialize${1}
    	${2}
    end

snippet defmm
    def method_missing(meth, *args, &blk)
    	${1}
    end

snippet defs
    def self.${1:class_method_name}
    	${2}
    end

snippet deft
    def test_${1:case_name}
    	${2}
    end

snippet detect
    detect { |${1:element}| ${2:body} }

snippet detecto
    detect do |${1:element}|
    	${2:body}
    end

snippet dglob
    Dir.glob(${1:"<+dir}"+>) { |${2:file}| ${3} }

snippet do
    do
    	${1}
    end

snippet dop
    do |${1:param}|
    	${2}
    end

snippet ea
    each { |${1:element}| ${2:body} }

snippet each
    each { |${1:element}| ${2:body} }

snippet each_with_index
    each_with_index { |${1:element},${2:i}| ${3:} }

snippet each_with_indexo
    each_with_index do |${1:element},${2:i}|
    	${3:body}
    end
    

snippet eacho
    each do |${1:element}|
    	${2:body}
    end

snippet eado
    each do |${1:element}|
    	${2:body}
    end

snippet eawi
    each_with_index { |${1:element},${2:i}| ${3:} }

snippet eawido
    each_with_index do |${1:element},${2:i}|
    	${3:body}
    end
    

snippet elsif
    elsif ${1:condition}
    	${2}

snippet fileeach
    File.foreach(${1:"<+path}"+>) { |${2:line}| ${3} }

snippet fopen
    File.open(${1:path}, "${2:rwab}") { |${3:file}| ${4} }

snippet fread
    File.read(${1})

snippet http_get
    require 'net/http'
    res = Net::HTTP.get URI.parse('${1:url}')

snippet http_post
    require 'net/http'
    res = Net::HTTP.post_form URI.parse('${1:url}')${2:, params}

snippet if
    if ${1:condition}
    	${2}
    end

snippet ife
    if ${1:condition}
    	${2}
    else
    end

snippet inj
    inject(${1:init}) { |${2:total}, ${3:next}| ${4:body} }

snippet injdo
    inject(${1:init}) do |${2:total}, ${3:next}|
    	${4:body}
    end

snippet inject
    inject { |${1:total},${2:next}| ${3:body} }

snippet injecto
    inject do |${1:total},${2:next}|
    	${3:body}
    end

snippet ip
    ip_addr = request.env['REMOTE_ADDR']

snippet map
    map { |${1:element}| ${2:body} }

snippet mapdo
    map do |${1:element}|
    	${2:body}
    end

snippet mapo
    map do |${1:element}|
    	${2:body}
    end

snippet Md
    File.open(${1:dump_path}, "wb") { |${2:file}| Marshal.dump(${3:obj}, ${4:$2}) }

snippet Ml
    File.open(${1:dump_path}, "rb") { |${2:file}| Marshal.load(${3:$2}) }

snippet mod
    module ${1:`Snippet_RubyClassNameFromFilename()`}
    	${2}
    end

snippet module
    module ${1:`Snippet_RubyClassNameFromFilename()`}
    	module ClassMethods
    		${2}
    	end
    
    	module InstanceMethods
    
    	end
    
    	def self.included(receiver)
    		receiver.extend         ClassMethods
    		receiver.send :include, InstanceMethods
    	end
    end

snippet nam
    namespace :${1:namespace} do
    	${2}
    end

snippet ope
    open(${1:path}, "${2:rwab}") { |${3:io}| ${4} }

snippet pathhere
    File.join(File.dirname(__FILE__), *%w[${1:rel_path_here}])

snippet Pn
    PStore.new(${1})

snippet r
    attr_reader :${1:attr_names}

snippet reject
    reject { |${1:element}| ${2:body} }

snippet rejecto
    reject do |${1:element}|
    	${2:body}
    end

snippet rep
    results.report("${1:name}:") { TESTS.times { ${2} } }

snippet rw
    attr_accessor :${1:attr_names}

snippet select
    select { |${1:element}| ${2:body} }

snippet selecto
    select do |${1:element}|
    	${2:body}
    end

snippet sinc
    class << self; self end

snippet sort
    sort { |${1:x},${2:y}| ${3:body} }

snippet sorto
    sort do |${1:x},${2:y}|
    	${3:body}
    end

snippet tas
    desc "${1:Task description}"
    task :${2:task_name}${3: => [:dependent, :tasks]} do
    	${4}
    end

snippet task
    desc "${1:Task description}"
    task :${2:task_name}${3: => [:dependent, :tasks]} do
    	${4}
    end

snippet tc
    require "test/unit"
    
    require "${1:library_file_name}"
    
    class Test${2:`Snippet_RubyClassNameFromFilename()`} < Test::Unit::TestCase
    	def test_${3:case_name}
    		${4}
    	end
    end

snippet unless
    unless ${1:condition}
    	${2}
    end

snippet unlesse
    unless ${1:condition}
    	${2}
    else
    end

snippet w
    attr_writer :${1:attr_names}

snippet while
    while ${1:condition}
    	${2}
    end

snippet xmlr
    REXML::Document.new(File.read(${1:path}))

snippet xpa
    elements.each(${1}) do |${2:node}|
    	${3}
    end

snippet Yd
    File.open(${1:path_to_yml}, "w") { |${2:file}| YAML.dump(${3:obj}, ${4:$2}) }

snippet Yl
    File.open(${1:path_to_yml}) { |${2:file}| YAML.load(${3:$2}) }

snippet zip
    zip(${1:enums}) { |${2:row}| ${3} }

